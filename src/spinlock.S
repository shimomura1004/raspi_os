.globl _spinlock_acquire
_spinlock_acquire:
    // ロック用の値 1 を x2 にセット
    mov   x2, #1
    // 次に実行する wfe に備えてカウンタを増やしておく
    sevl
1:
    // 初回は sevl 実行済みなのですぐに復帰する
    wfe
2:
    // アドレス x0 が指す値を x1 に読み込みつつ、排他モニタを有効にする
    // 他の CPU がモニタ中のアドレスに書き込むと、モニタがクリアされる
    // stxr を実行するときに排他モニタがクリアされていると書き込みに失敗する
    ldaxr x1, [x0]
    // x1 が 0 以外だった場合はロック中だったのでリトライ(b: backward)
    // 既に誰かがロックを取っているということなので、wfe で待つ
    cbnz  x1, 1b
    // x1 が 0 だった場合はロックされていないので、x2(=1) を [x0] に書き込みロックを試みる
    // もし排他モニタがクリアされていると、[x0] は更新されず w3 に 1 がセットされる
    stxr  w3, x2, [x0]
    // w3 が 0 以外だった場合はロックに失敗したということなのでリトライ
    cbnz  w3, 2b
    ret

// For armv8.1 or later
//    // ロック用の値 1 を x2 にセット
//    mov   x2, #1
//1:
//    // x1 は 0 で初期化
//    mov   x1, xzr
//2:
//    // アドレス x0 の指すメモリの内容を読み取り、x1(=0) と比較
//    // 0 だった場合(ロックされてなかった場合)は
//    //   x1 <- [x0]
//    //   [x0] <- x2
//    // 0 じゃなかった場合(ロックされていた場合)はそのまま
//    casal x1, x2, [x0]
//    // x1 が 0 だった場合はロックを取得できたので 3 にジャンプ(f: forward)
//    cbz   x1, 3f
//
//    // ここからはロックに失敗した場合の処理
//    // 失敗した場合はすぐにメモリをチェックし、空いていたらリトライする
//
//    // ldxr 命令で x0 の指すメモリの内容を読み取り x1 にセット
//    ldxr  x1, [x0]
//    // ロックされてなかった場合はすぐにリトライ(b: backward)
//    cbz   x1, 2b
//    // ロックされていた場合はしばらく待つ
//    wfe
//    b     1b
//3:
//    ret

.globl _spinlock_release
_spinlock_release:
    // 既にロックを取得していることが前提なので、素直にメモリ書き込み
    // stlr はメモリバリア付きのストア命令で、この命令が実行される前に、以前の命令は必ず実行される
    // [x0] に 0 を書き込み (=解放)
    stlr xzr, [x0]
    // wfe で待っている CPU を起こす
    sev
    ret
